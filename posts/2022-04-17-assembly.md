---
title:  "ç®€å•(é™‹)çš„x86æ±‡ç¼–è¯­è¨€æ•™ç¨‹"
date:   '2022-04-16'
author: 'Qiping Pan'
tag: 'Tech'
description: 'Look mom I am writing assembly code'
---


## å•¥æ˜¯æ±‡ç¼–è¯­è¨€ï¼Ÿ

æ±‡ç¼–è¯­è¨€å…¶å®ä¸ç®—æ˜¯æŸä¸€ä¸ªè¯­è¨€ï¼Œè€Œæ˜¯ä¸€ç§"human readable machine code"ã€‚æ¯”èµ·é«˜çº§è¯­è¨€æ›´æ¥è¿‘åº•å±‚çš„æœºå™¨è¯­è¨€ï¼Œæ‰€ä»¥ä¹Ÿæ›´åŠ å¤æ‚å’Œå†—é•¿ã€‚æ±‡ç¼–è¯­è¨€æ˜¯ç›´æ¥ä¼ ç»™cpuçš„æŒ‡ä»¤ï¼Œæ‰€ä»¥ä¸cpuçš„æ¶æ„éå¸¸ç›¸å…³ã€‚

æ±‡ç¼–è¯­è¨€æœ‰ä»¥ä¸‹å‡ ä¸ªç‰¹å¾ï¼š
1. å’Œå¯„å­˜å™¨äº¤äº’ã€‚æ¯ä¸ªå¯„å­˜å™¨æœ‰ä¸åŒçš„ç›®çš„ï¼Œä½†å­˜å‚¨çš„é•¿åº¦æ˜¯ç›¸åŒçš„ï¼Œä¹Ÿå’Œcpuæ¶æ„ç›¸å…³ï¼Œ32-bitçš„æœºå™¨ï¼Œå¯„å­˜å™¨å°±æ˜¯32-bité•¿çš„ã€‚
2. å’Œæ ˆäº¤äº’ã€‚æ ˆæ˜¯ä¸€ä¸ªLIFO(last in, first out)çš„æ•°æ®ç»“æ„ã€‚åœ¨å†…å­˜ä¸­ï¼Œå…¶å®å°±çœ‹ä½œä¸€ä¸ªæ•°ç»„ï¼Œå› ä¸ºå¯ä»¥è®¿é—®ä»»æ„ä½ç½®(random access)ã€‚æ ˆçš„ä¸»è¦å®ç°æ˜¯é€šè¿‡ä¸€ä¸ªæ ˆé¡¶æŒ‡é’ˆ(å­˜å‚¨åœ¨å¯„å­˜å™¨espä¸­)ã€‚popå’Œpushå°±ä»¥è¿™ä¸ªæŒ‡é’ˆä¸ºå‚è€ƒã€‚


## å¸¸é‡ç±»å‹
```plaintext
db: 1 byte
dw: 2 byte
dd: 4 byte
```
x86æ±‡ç¼–ä¸­æœ‰ä¸‰ç§å¯ä»¥å£°æ˜çš„å¸¸é‡ç±»å‹ï¼ˆæˆ–è€…åªæœ‰æˆ‘é‚£ä¹ˆå«ï¼Ÿï¼‰ï¼Œä»–ä»¬çš„ä¸»è¦åŒºåˆ«åœ¨äºé•¿åº¦ä¸åŒã€‚
* `db`: 1 å­—èŠ‚ï¼Œ åŒ…æ‹¬åå…­è¿›åˆ¶æ•°(hexidecimal, e.g. `0xff`), å­—ç¬¦(`'s'`), 1ä¸ªå­—èŠ‚èƒ½è¡¨ç¤ºçš„æ•´å½¢(`100`)
* `dw`: 2 å­—èŠ‚ï¼Œæ›´å¤§çš„æ•´å‹
* `dd`: 4 å­—èŠ‚ï¼Œæ›´æ›´å¤§çš„æ•´å‹


## åŸºæœ¬è¯­æ³•

ä»¥æ“ä½œç¬¦å¼€å¤´ï¼Œåé¢æ˜¯æ¶‰åŠåˆ°çš„è¿ç®—å•ä½ï¼Œç”¨é€—å·åˆ†éš”ã€‚
```plaintext
operation [operands, ...]
```

ğŸŒ° ï¼š
```plaintext
mv  ebx, 123    ; ebx = 123
mv  ebx, ecx    ; ebx = ecx
add ebx, ecx    ; ebx += ecx
mul ebx         ; eax *= ebx æ³¨æ„ï¼Œä¹˜æ³•é™¤æ³•é»˜è®¤åœ¨eaxä¸Šæ“ä½œ
```

## å¯„å­˜å™¨ä¸æ ˆ

ä¸€äº›é‡è¦çš„ç‰¹æ®ŠåŠŸèƒ½å¯„å­˜å™¨ã€‚

### EIP
åœ¨è®¡ç®—æœºä¸­ï¼Œcpuè¯»å–çš„æ¯ä¸€æ¡æŒ‡ä»¤ï¼Œå…¶å®ä¹Ÿæ˜¯å­˜å‚¨åœ¨å†…å­˜ä¸­çš„æ•°æ®ï¼ˆè¿™ç§æŒ‡ä»¤å’Œæ•°æ®çš„çº è‘›ä¸æ¸…ä¹Ÿå¸¦æ¥äº†å¾ˆå¤šå®‰å…¨é—®é¢˜ï¼Œæ¯”å¦‚buffer overflowï¼Œä½†è¿™äº›å°±è·‘è¿œäº†ï¼‰ã€‚cpué€šè¿‡è¯»å–EIPæ‰€å‚¨å­˜çš„å†…å­˜åœ°å€ä¸­çš„æ•°æ®æ¥çŸ¥é“ä¸‹ä¸€æ¡æŒ‡ä»¤æ˜¯ä»€ä¹ˆï¼ŒåŒæ ·ä¹Ÿå¯ä»¥é€šè¿‡è¦†å†™EIPæ¥å®ç°è·³è½¬ã€‚è·³è½¬å¯ä»¥åº”ç”¨åœ¨è®¸å¤šåœºæ™¯ä¸­ï¼Œå¦‚æœæ˜¯å‘å‰è·³è½¬å°±æ˜¯åˆ†æ”¯ç»“æ„ï¼ˆifï¼‰ï¼Œå‘åè·³è½¬å°±æ˜¯å¾ªç¯ï¼ˆwhileï¼‰ï¼Œå‘æŸä¸ªåœ°å€è·³è½¬ä¹Ÿå¯ä»¥æ˜¯å‡½æ•°è°ƒç”¨ç­‰ç­‰ã€‚ä¸‹é¢æ˜¯ä¸ªç®€å•çš„ä¾‹å­ï¼š
```plaintext
_start:
    ...// first execute some code here
    jmp skip
    ...// never gets executed

skip:
    ...// second execute some code here
```

### æ ˆä¸ESP
å¦‚ä¸Šæ–‡æ‰€è¯´ï¼Œæ ˆå°±æ˜¯ä¸€å—æœ‰LIFOæ€§è´¨çš„å†…å­˜ã€‚ESPå¯„å­˜å™¨å‚¨å­˜æ˜¯æ ˆé¡¶çš„ä½ç½®ï¼Œæ‰€ä»¥popç›¸å½“äºæŠŠESPä½ç½®ä¸Šçš„å†…å®¹å–å‡ºï¼Œç„¶å`ESP += 4`ï¼Œ å³å¾€ä¸‹ç§»åŠ¨4ä¸ªbyteã€‚pushåŒç†ã€‚

```plaintext
push 100    ; [100][][][][] stack top
              ^(esp)

push 302    ; [100][302][][][]
                    ^(esp)

sub esp 4   ; å…ˆå‘ä¸Šç§»åŠ¨espï¼Œå†ç»™espæ‰€åœ¨ä½ç½®èµ‹å€¼ï¼Œå’Œpushæ˜¯ç­‰ä»·çš„
mov [esp], dword 345; [100][302][345][][]
                                 ^(esp)

pop eax     ;  [100][302][345][][]
                     ^(esp)
            ; æŠŠæ ˆé¡¶å…ƒç´ å‚¨å­˜åˆ°eaxä¸­ã€‚æ­¤æ—¶å…¶å®åªç§»åŠ¨äº†espï¼Œæ ˆçš„å…ƒç´ æ²¡æœ‰å˜åŒ–

mov eax, dword [esp]; è¿™ä¸¤ä¸ªæ“ä½œå’Œpopç­‰ä»·
add esp, 4
```

### å‡½æ•°è°ƒç”¨
å‡½æ•°è°ƒç”¨å’Œæ ˆä¸ESPï¼ŒEIPéƒ½æ¯æ¯ç›¸å…³ã€‚é¦–å…ˆå‡½æ•°è°ƒç”¨ä½¿ç”¨çš„æ˜¯ä¸€ä¸ªæ–°çš„æ“ä½œï¼š`call`ã€‚å®ƒåšçš„äº‹æƒ…åŒ…æ‹¬ï¼š
1. æŠŠå½“å‰EIPçš„å€¼ï¼ˆå³è¿™ä¸ªå‘½ä»¤çš„åœ°å€ï¼‰pushåˆ°æ ˆä¸­
2. æ‰§è¡Œä¸€ä¸ªjumpï¼Œè¦†å†™EIPä¸ºè·³è½¬åˆ°å‡½æ•°çš„åœ°å€

```plaintext
_start:
    ...         ; things before function
    call func   ; call function
    ...         ; things after function

func:
    ...         ; things in the function
    pop eax     ; get the return address from the stack
    jump eax    ; jump back to the caller
```

æˆ‘ä»¬æœ€åé€šè¿‡`pop`å’Œ`jump`æ“ä½œæ¥è·å–å¹¶è·³è½¬åˆ°è¿”å›çš„åœ°å€ã€‚ä¹Ÿå¯ä»¥ä½¿ç”¨`ret`æ¥ä»£æ›¿è¿™ä¸¤ä¸ªæŒ‡ä»¤ã€‚æ³¨æ„åˆ°ï¼Œ**è¿™æ„å‘³ç€åœ¨å‡½æ•°æ‰§è¡Œç»“æŸåï¼Œæˆ‘ä»¬ä¸€å®šè¦ä¿è¯æ ˆé¡¶å…ƒç´ å°±æ˜¯è¿”å›åœ°å€**ï¼Œå¦åˆ™å°±ä¸çŸ¥é“`jump`åˆ°å“ªé‡Œå»äº†ã€‚ä¸€ä¸ªæ™®éçš„åšæ³•æ˜¯ä½¿ç”¨"base pointer", å³EBPï¼Œæ¥ä¿è¯retçš„æ˜¯æ­£ç¡®åœ°å€ã€‚EBPä¿å­˜ç€åœ¨è¿›å…¥å‡½æ•°æ—¶çš„æ ˆé¡¶å…ƒç´ ï¼ˆå³è¿”å›åœ°å€ï¼‰ã€‚

```plaintext
func:
    mov ebp, esp    ; åœ¨è¿›å…¥å‡½æ•°æ—¶ï¼ŒæŠŠæ ˆé¡¶å…ƒç´ å­˜åˆ°ebpä¸­
    ...             ; do whatever
    mov esp, ebp    ; å³å°†æ•´ä¸ªå‡½æ•°è°ƒç”¨æ ˆéƒ½æ¸…ç©ºï¼Œä¿è¯æ ˆé¡¶æ—¶è¿”å›åœ°å€
    ret             ; retä¸€å®šåˆæ³•
```

ä½†è¿™ä¸ªæ“ä½œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼šå‡½æ•°ä¸­åˆè°ƒç”¨äº†å‡½æ•°ï¼Œæ¯”å¦‚è¿™ç§æ‰§è¡Œé¡ºåº, ä¼šä½¿å¾—å¤–å±‚å‡½æ•°çš„EBPè¢«å†…å±‚å‡½æ•°è¦†ç›–æ‰ï¼Œæ²¡æ³•è¿”å›æ­£ç¡®çš„åœ°å€ã€‚

```plaintext
mov ebp, esp    ; function 1 called
call func2      ; function 1 call function 2
mov ebp, esp    ; function 2 called
...             ; function 2 execute
mov esp, ebp    ; function 2 returns
ret             ;
mov esp, ebp    ; function 1 returns, but ebp has already been overwritten
```

ç®€å•çš„å¤„ç†åŠæ³•æ˜¯ï¼ŒæŠŠEBPä¹Ÿç»™pushåˆ°æ ˆä¸Šï¼Œç„¶ååœ¨å‡½æ•°è¿”å›æ—¶popã€‚

```plaintext
push ebp        ;   å‚¨å­˜ç€callerçš„è¿”å›åœ°å€ï¼Œè¿™æ ·å°±ä¿è¯ä¸ä¼šå› ä¸ºè¦†ç›–ebpè€Œä¸¢æ‰
mov ebp, esp    ;   å¸¸è§„æ“ä½œï¼Œä¿å­˜å½“å‰å‡½æ•°çš„è¿”å›åœ°å€
...             ;   do whatever
mov esp, ebp    ;   æ¸…ç©ºæ ˆ
pop ebp         ;   è¿˜åŸcallerçš„ebp
ret
```

å¯¹åº”åˆ°æ ˆçš„æƒ…å†µå°±æ˜¯
```plaintext
push ebp        ;   [return_address][previous_ebp][][][]    ebp=previous_ebp
mov ebp, esp    ;   ebp updated
...             ;   [return_address][previous_ebp][stuffs][][]
mov esp, ebp    ;   [return_address][previous_ebp][][][]
pop ebp         ;   [return_address][][][][]    ebp=previous_ebp       
ret             ;
```

`mov esp, ebp; pop ebp`ä¹Ÿå¯ä»¥ç”¨`leave`ä»£æ›¿ã€‚

### å‡½æ•°ä¼ å‚å’Œè¿”å›

å‡½æ•°çš„calleråœ¨è°ƒç”¨å‡½æ•°ä¹‹å‰ï¼Œå¯ä»¥æŠŠå‚æ•°pushåˆ°æ ˆä¸Šã€‚æ‰€ä»¥æ ˆçš„æœ€ç»ˆæ„æˆæ˜¯è¿™æ ·çš„:

|æ ˆé¡¶ï¼ˆESPï¼‰
|--|
|å‡½æ•°çš„æœ¬åœ°å˜é‡ (callee push)
|previous EBPï¼ˆå³callerçš„è¿”å›åœ°å€, callee pushï¼‰
|return address (caller push)
|å‡½æ•°å‚æ•° (caller push)

ä¸€ä¸ªç®€å•çš„ä¾‹å­, è€ƒè™‘åªæœ‰ä¸€ä¸ªå‚æ•°(4 byte)çš„å‡½æ•°

```plaintext
caller:
    push 1          ; argument is 1
    call func

func:
    push ebp        ;   push previous_ebp
    mov ebp, esp    ;
    mov eax, [ebp+8];   è·å–å‚æ•°
                    ;   +8æ˜¯å› ä¸ºè¦è¶Šè¿‡previous_ebpå’Œcaller pushçš„return address
                    ;   å¦‚æœæ˜¯ç¬¬nä¸ªå‚æ•°ï¼Œå°±æ˜¯ epb+8+4*(n-1)
```



## å…¶å®ƒçš„æ“ä½œç¬¦ä»‹ç»

å…¶å®ä¸»è¦æƒ³è®²`LEA`ã€‚LEA(Load Effective Address)çœ‹å­—é¢æ„æ€æ¯”è¾ƒéš¾ä»¥æ‰æ‘¸ã€‚
> The LEA instruction loads an address. If you have some varaible, you can load the address of it into a register and manipulate the data indirectly with the register as a pointer. LEA does not change any flags.

ç®€å•æ¥è¯´å°±æ˜¯æŠŠä¸€ä¸ªå˜é‡çš„åœ°å€å­˜åˆ°å¯„å­˜å™¨ä¸­ï¼Œå¯ä»¥é€šè¿‡è¿™ä¸ªå¯„å­˜å™¨æ¥é—´æ¥ä¿®æ”¹è¿™ä¸ªå˜é‡çš„å€¼ã€‚ä¸å°±æ˜¯æŒ‡é’ˆå˜›ï¼`LEA`æŠŠå˜é‡çš„åœ°å€å­˜åˆ°å¯„å­˜å™¨ï¼Œ`MOV`æŠŠå˜é‡çš„æ•°æ®å­˜åˆ°å¯„å­˜å™¨ã€‚

è¯­æ³•: `lea dst, src`
ä¾‹å­:

```plaintext
variable db 123

_start:
lea eax, variable       ;       æŠŠvariableçš„åœ°å€å­˜åˆ°eaxä¸­
mov byte ptr [eax], 345 ;       é€šè¿‡eaxä¿®æ”¹variable
```


## ä»£ç åˆ†æç¤ºä¾‹

çœ‹çœ‹è¿™æ®µä»£ç åšäº†å•¥äº‹

```plaintext
push    ebp                     ; è¿›å…¥å‡½æ•°
mov     ebp, esp                ;
push    ebx                     ; ebx pushåˆ°æ ˆä¸Š
sub     esp, 0x8                ; esp -= 8ï¼Œç›¸å½“äºå¼€äº†8ä¸ªå­—èŠ‚çš„buffer
push    dword ptr [ebp + 0x8]   ; ebp + 0x8 å°±æ˜¯ç¬¬ä¸€ä¸ªå‚æ•°çš„ä½ç½®ï¼Œpushåˆ°æ ˆä¸Šï¼Œä½œä¸ºstrcpyå‡½æ•°å‚æ•°
lea     edx=>local_10, [ebp + -0xc]; æŠŠebp - 12çš„åœ°å€å­˜åˆ°edxä¸­ï¼Œæ³¨æ„ebp - 12å°±æ˜¯bufferçš„å¼€å§‹
push    edx                     ; edx pushåˆ°æ ˆä¸Šï¼Œä½œä¸ºstrcpyå‡½æ•°å‚æ•°
mov     ebx, eax                ;
call    strcpy
...
```

æ‰€ä»¥ä¸Šè¿°æ“ä½œå°±æ˜¯
```c
void func(char *param){
    char local_10[8];
    strcpy(local_10, param);
}
```