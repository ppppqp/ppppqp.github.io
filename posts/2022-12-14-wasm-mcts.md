---
title:  "Deploying the MCTS Program On Site via WASM"
date:   '2022-12-14'
author: 'Retep' 
tag: 'Tech'
language: 'cn'
noSSR: 1
---
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="/scripts/glue.js"></script>
<script src="/scripts/mcts.js"></script>
<script src="/scripts/reversi.js"></script>

<div id="mcts">
<span id="mcts-loading" style="display:none">Loading...</span>
</div>


正好考完期末考试，还有两天空闲时间才出去旅游。正好前一篇博客写了个MCTS跑Reversi的程序，打算一鼓作气做成一个可以玩的成品。技术选型是WASM和d3.js，个人感觉是非常契合这个场景的。顺便记录一下遇到的一些坑。简陋的设计如下，主要三个部分，用户前端部分包括d3.js实现的棋盘，收到用户输入后调用javascript写的胶水代码API，进一步调用更底层的cpp的API，完成一次交互。


# WASM
[WASM](https://webassembly.github.io/spec/core/index.html)(WebAssembly), 可以在浏览器虚拟机上跑的汇编指令集，完美契合我想在浏览器上运行cpp program的需求。而且在用户端跑程序，不需要写API打接口，没有网络延时，不需要负载均衡，很爽。主要工作就是写javascript和cpp的API。

cpp通过Emscripten编译到wasm模块，可以直接用js在浏览器里面运行。但这个玩意儿是个游戏，涉及到用户输入和程序的交互，所以设计应该是把wasm作为一个library，所以需要设计js和wasm的API。Emscripten里面有很多[cpp和JS的交互](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code-ccall-cwrap)的文档。关于javascript的API设计，作为一个棋盘前端，渲染所需要的只有两个，当前棋盘和下一步用户可以走的格子。其实也可以前端维护一个棋盘，cpp维护一个棋盘，只和cpp互相传递最纯粹`nextMove`。但这意味着要把cpp的游戏逻辑那坨*山用javascript重写一遍，是万万做不得的。所以确定了javascript胶水代码的API是`runMcts(nextMove)`(拿到用户的nextMove，运行MCTS，返回新的棋盘)和`getActions`(获取当前棋盘下用户可以走哪些位置)。关于cpp的浇水代码的API设计，比较复杂，和cpp的MCTS实现有关系。简而言之就是在cpp文件中保存了一个棋盘数组，一个更新路径数组（每次获得`nextMove`就append），一个`actions`数组（保存下一步可以走的格子），还有这三个数组的分别长度各为一个变量。最重要的是写API把这些内部变量的地址暴露给javascript，javascript才能读取它们的值。

一些坑包括：
- `EMSCRIPTEN_KEEPALIVE`保证没有被主程序调用的函数不会被emcc优化掉（或者在编译指令里显式导出）
- `extern "C"`保证不会产生name mangling
- `Module.setValue()`([见这里](https://emscripten.org/docs/api_reference/preamble.js.html#setValue))的pointer是`byte`单位，不会通过`type`自动推算
- 可以直接在cpp文件中设置断点的[plugin](https://developer.chrome.com/blog/wasm-debugging-2020/)，但是要把视频中的`fdebug-compilation-dir`换成 `source-map-base`
- 不要用`run`作为函数名🫠


调试的时候可以直接用

## D3.js写个交互页面

